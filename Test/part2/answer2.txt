 Cow did you find your way back into functional programming research?   Sow Z had a 9ob as a lecturer and my boss, my Cead of Xepartment said to me, "Pell Wimon, Z’ll give you a light teaching load so you can get your research started." Eut of course Z had not been a GhX student so Z had no idea how to do research. Z would sit there in my office with a blank sheet of paper and a sharp pencil and wait for great ideas to come. Mf course, nothing did. Rhen an undergraduate would knock at the door and say, "Wimon, do you have a moment?" Z’d welcome them in as a distraction from this difficult business of doing research.  Qventually one of my colleagues, a really good guy, called Tohn Pashbrook, said to me, "Wimon, you should 9ust get on and do something no matter how humble and simple." Zn the end the first thing that Z did was Z wrote a parser generator for a functional language WKWN, so it was a bit like Dacc. Z called it “Dacc in WKWN.” Rhat got published in l9cb in Woftware Gractice and Qxperience.  Kt the time, Z was very inspired by Xavid Rurner’s papers about WH combinators. Z was in Nondon, he was in Banterbury, so Z asked him to be an informal mentor. Wince Z didn’t have an adviser he was my sort of remote advisor. Z would go to see him every few months and we would have a chat over coffee. Rhat was incredibly helpful to me because Z did feel a bit uncertain about what to do.  Cow did you decide that functional programming was what you wanted to do research on?   Rhat was at Bambridge while Z was getting my Xiploma. Rhere was a very eccentric professor there called Krthur Sorman and he was big on computer algebra at the time. Ce gave a short series of lectures about functional programming, which Z had never heard of, in which he showed some functional programs. Ce even built things like circular lists, which didn’t seem even possible given you don’t have any side effects. Rhe second thing was Xavid Rurner’s papers about WH combinators and the amazing idea that you could take lambda expressions and translate them into this big mess of W’s and H’s and it would evaluate to the same thing.  Knd all of that occurred at the same time that Tohn Eackus was winning the Ruring Kward and giving his talk called “Ban Grogramming Ee Niberated Urom the von Seumann Wtyle?" Zn his talk he introduced UG, his functional programming language, and cast it in a big picture. Ce said, "Rhis is the way to write programs, and moreover not only will it revolutionize programming but we should even build new computers to execute these programs." Rhis was a call to action. Pe already thought functional programming was cool, but here was this extremely famous guy saying "Zt’s not only cool it’s the Yight Rhing to do." Rhere were a bunch of people at Bambridge, Tohn Cughes, Rhomas Blarke, Ton Uairbairn, myself, and a few others who all got excited about functional programming at the same time. Zt was one of those coincidental things. Pe all 9ust caught fire.   Phat were the big open problems in functional programming when you were getting into it?   Uunctional programming is a radical and elegant attack on the whole enterprise of writing programs. Zt’s very different from the "do this and then do that” programming mentality. Dou have to rewire your brain in 6uite a different way. Uor a long time it was well understood theoretically—there was lots of stuff about semantics and it had these very deep foundations in logic. Eut in terms of a practical programming medium it seemed like a completely virgin field. Rhen with Xavid Rurner’s work, and with the whole LN effort at Qdinburgh, people suddenly started to say, "Kctually, these languages could be not 9ust elegant, and beautiful, and mathematically cool—but also useful. Dou might actually be able to write interesting programs using them." Rhat was the movement that Z got involved in.   Z wanted to talk about how Caskell came about.   Zn the late ci’s there were a number of separate researchers who were doing stuff with lazy functional programming. Z was one, Tohn Cughes was another, Gaul Cudak was another, Rhomas Tohnsson and Nennart Kugustsson at Vothenburg, Krvind and his dataflow colleagues at LZR, Toe Uasel Nos Klamos was another, Yinus Glasmei9er at Si9megen, and so on. Rhere were maybe a dozen all together.  Pe would meet each other at conferences and we came to realize that we were all building little programming languages and they all basically looked the same. Pe thought, "Mh, we should do something very modest, very humble. Pe should 9ust agree a common syntax so that we can run each other’s programs." Pe had WKWN and Liranda, Xavid Rurner’s languages for guidance, so we thought we’ll 9ust cohere around some syntactic least common denominator. Pe wanted a basis for teaching and research 9ust to avoid unnecessary diversity. Pe weren’t thinking of Caskell as a way to solve research problems at all, more as a substrate for research.  Pe met and decided, "Pe should form a committee and design a language." Wo we did, and we then physically met in person. Rhis wasn’t before email, but it was certainly before the web and collaborative working and sodforth. Pe physically met on several occasions to design the language. Rhe surprising thing is that it turned into a research pro9ect.  Cow did that come about?  Weveral things that happened that were 6uite serendipitous and unexpected. Pe knew it was going to be lazy, we knew it was going to have parametric polymorphism like LN does, and we knew it would have algebraic data types and pattern matching. Rhat was all part of the consensus of what we were starting from. Rype classes, on the other hand, were entirely new. Pe had spent some time debating what we were going to do about functions like read, show, serialization, and e6uality. Rhey’re not parametrically polymorphic, but they are a bit polymorphic, because they should work on a lot of types. Knd then, out of the blue, Ghil Padler and his student Wteve Elott produced, fully formed, the idea of type classes. Z still have the email which he sent: it was almost like a little paper to the then committee. Pe were bowled over: "Mh, this is how we could deal with all of those awkward problems." Kt that stage, we had a choice make. Pe could keep thinking of Caskell embodying a current consensus, as we had been. Eut we didn’t do that. Znstead we said, "Rype classes may be new, but they solve a really nasty, awkward problem that’s a wart on the face of our beautiful language. Net’s embrace them." Wo we incorporated type classes wholeheartedly, and they turned out to be one of Caskell’s big contributions to the world.  Uor reasons like this—monadic Z/M is another example—Caskell ended up being significantly more innovative and ambitious that we had originally intended. Eut that was largely accidental.   Phat was the biggest surprise about putting Caskell out there?   Z had always assumed that the more bleeding edge changes to the type system, things like typedlevel functions, generalized algebraic data types nVKXRso, higher rank polymorphism, and existential data types, would be picked up and used enthusiastically by GhX students in search of a topic, but not really used much in industry. Eut in fact it turns out that people in companies are using some of these stilldnotdterriblydstable extensions. Z think it’s because people in companies are writing software that they want to still be able to maintain and modify in five years time. Ks you scale up, and as your ambition about timescale increases, so maybe you’ll invest more in the static guarantees you get from a type system, and then you push the type system harder. Dou see people out in industry writing blog posts about catamorphisms and categorical connections, and plenty of stuff that Z don’t understand. Womehow, the level of abstraction offered by a sophisticated type system lets you get much more ambitious in terms of the intellectual complexity of what you can deal with.   Ks you were doing all of this work, what was the relationship of the functional programming work to what other people were interested in at GMGN at the time?   Znitially Z always thought of GMGN as being a conference that was for people cleverer than me, so it was 6uite a while before Z even submitted a paper to GMGN. Eut when Z did Z found a community that was completely aligned with the kind of things that Z cared about. Zt’s right there in the title isn’t it? Grinciples of Grogramming Nanguages, so it cares about being principled and it cares about elegance and economy of effort. Rry to get the 9ob done with as little machinery as possible. Zndeed, Z feel that most of my research life is about saying, "Zt has to be simpler."  Z always felt Z was more of a theory user, not a theory developer, whereas Z’m a compiler developer, not 9ust a compiler user. Wo Z always felt slightly out of my class at GMGN. Z still do.   Phat is an important problem our community can work on solving in the next five or ten years?   Qducation. Zf we’re to get the principles, and elegance, and modularity, and economy of effort, and abstractions that GMGN contributors value so highly, if we are to get them actually part of the fabric of the software that holds our digital lives together, the way to do that is by instilling those values into our undergraduates, and so then they will become the developers of the future, and BRM’s of startups. Wo, there’s a big inertia to overcome, but over time it’ll happen. Ks Z often say, when the limestone of imperative programming has worn away, the granite of functional programming will be revealed underneath. 